package ro.helator.dia.server;

import java.io.BufferedReader;
import java.io.BufferedWriter;
import java.io.Closeable;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.OutputStreamWriter;
import java.nio.file.Files;
import java.nio.file.LinkOption;
import java.nio.file.Path;
import java.nio.file.Paths;
import java.util.HashMap;
import java.util.Objects;
import java.util.Optional;
import java.util.concurrent.LinkedBlockingQueue;
import java.util.stream.Collectors;

//import com.fasterxml.jackson.core.JsonProcessingException;
//import com.fasterxml.jackson.databind.ObjectMapper;
//import com.pty4j.PtyProcess;
//import com.pty4j.WinSize;
//import com.sun.jna.Platform;
import com.terminalfx.annotation.WebkitCall;
import com.terminalfx.config.TerminalConfig;
import com.terminalfx.helper.IOHelper;
import com.terminalfx.helper.ThreadHelper;

import javafx.scene.Node;
import javafx.scene.control.Tab;
import javafx.scene.input.Clipboard;
import javafx.scene.input.ClipboardContent;
import javafx.scene.web.WebEngine;
import javafx.scene.web.WebView;
import netscape.javascript.JSObject;

public class TerminalTab extends Tab {

	private Server server;
	
	private WebView webView;
	private int columns = 150;
	private int rows = 15;
//	private PtyProcess process;
	private BufferedReader inputReader;
	private BufferedReader errorReader;
	private BufferedWriter outputWriter;
	private Path terminalPath;
	private boolean isReady = false;
	private String[] termCommand;
	private LinkedBlockingQueue<String> commandQueue;
	private TerminalConfig terminalConfig = new TerminalConfig();
	
	public TerminalTab(TerminalConfig terminalConfig, Server server,  Path terminalPath) {
		this.terminalConfig = terminalConfig;
		this.terminalPath = terminalPath;
		this.server = server;
		this.initialize();
	}
	
	public TerminalTab() {
		this.initialize();
	}

	public TerminalTab(String text) {
		super(text);
		this.initialize();
	}

	public TerminalTab(String text, Node content) {
		super(text, content);
		this.initialize();
	}
	
	public JSObject getWindow() {
		return (JSObject) this.webEngine().executeScript("window");
	}

	private WebEngine webEngine() {
		return this.webView.getEngine();
	}
	
	public void initialize() {
		this.commandQueue = new LinkedBlockingQueue<String>();
		this.webView = new WebView();
		this.webView.getEngine().getLoadWorker().stateProperty().addListener((observable, oldValue, newValue) -> {
			this.getWindow().setMember("app", this);
		});
		this.webEngine().load(TerminalTab.class.getResource("/hterm.html").toExternalForm());
		String tabName = server.getName();
		this.setText(tabName);
	}
	
	@WebkitCall(from = "hterm")
	public String getPrefs() {
		try {
			return (new ObjectMapper()).writeValueAsString(this.getTerminalConfig());
		} catch (JsonProcessingException arg1) {
			throw new RuntimeException(arg1);
		}
	}
	
	public void updatePrefs(TerminalConfig terminalConfig) {
		if (!this.getTerminalConfig().equals(terminalConfig)) {
			this.setTerminalConfig(terminalConfig);
			String prefs = this.getPrefs();
			ThreadHelper.runActionLater(() -> {
				try {
					this.getWindow().call("updatePrefs", new Object[] { prefs });
				} catch (Exception arg2) {
					arg2.printStackTrace();
				}

			}, true);
		}
	}

	@WebkitCall(from = "hterm")
	public void resizeTerminal(int columns, int rows) {
		this.columns = columns;
		this.rows = rows;
		if (Objects.nonNull(this.process)) {
			ThreadHelper.runActionLater(() -> {
				this.process.setWinSize(new WinSize(columns, rows));
			}, true);
		}

	}

	@WebkitCall
	public void onTerminalInit() {
		ThreadHelper.runActionLater(() -> {
			this.setContent(this.webView);
		}, true);
	}

	@WebkitCall
	public void onTerminalReady() {
		ThreadHelper.start(() -> {
			this.isReady = true;

			try {
				this.initializeProcess();
			} catch (Exception arg1) {
				;
			}

		});
	}

	@WebkitCall
	public void command(String command) throws InterruptedException {
		this.commandQueue.put(command);
		ThreadHelper.start(() -> {
			try {
				this.outputWriter.write((String) this.commandQueue.poll());
				this.outputWriter.flush();
			} catch (IOException arg1) {
				arg1.printStackTrace();
			}

		});
	}

	public void print(String text) {
		ThreadHelper.runActionLater(() -> {
			this.getTerminalIO().call("print", new Object[] { text });
		});
	}
	
	public void focusCursor() {
		ThreadHelper.runActionLater(() -> {
			this.webView.requestFocus();
			this.getTerminal().call("focus", new Object[0]);
		}, true);
	}

	private JSObject getTerminal() {
		return (JSObject) this.webEngine().executeScript("t");
	}

	private JSObject getTerminalIO() {
		return (JSObject) this.webEngine().executeScript("t.io");
	}

	private void initializeProcess() throws Exception {
		String userHome = System.getProperty("user.home");
		Path dataDir = Paths.get(userHome, new String[0]).resolve(".terminalfx");
		IOHelper.copyLibPty(dataDir);
		if (Platform.isWindows()) {
			this.termCommand = this.terminalConfig.getWindowsTerminalStarter().split("\\s+");
		} else {
			this.termCommand = this.terminalConfig.getUnixTerminalStarter().split("\\s+");
		}

		HashMap envs = new HashMap(System.getenv());
		envs.put("TERM", "xterm");
		System.setProperty("PTY_LIB_FOLDER", dataDir.resolve("libpty").toString());
		if (Objects.nonNull(this.terminalPath) && Files.exists(this.terminalPath, new LinkOption[0])) {
			this.process = PtyProcess.exec(this.termCommand, envs, this.terminalPath.toString());
		} else {
			this.process = PtyProcess.exec(this.termCommand, envs);
		}

		this.process.setWinSize(new WinSize(this.columns, this.rows));
		this.inputReader = new BufferedReader(new InputStreamReader(this.process.getInputStream()));
		this.errorReader = new BufferedReader(new InputStreamReader(this.process.getErrorStream()));
		this.outputWriter = new BufferedWriter(new OutputStreamWriter(this.process.getOutputStream()));
		ThreadHelper.start(() -> {
			this.printReader(this.inputReader);
		});
		ThreadHelper.start(() -> {
			this.printReader(this.errorReader);
		});
		this.focusCursor();
		this.process.waitFor();
	}
	
	private String detectTerminalCharacter() {
		String charset = "UTF-8";
		return Platform.isWindows() ? (String) this.windowsCmdCharset().orElse(charset)
				: (String) this.unixTerminalCharset().orElse(charset);
	}

	private void printReader(BufferedReader bufferedReader) {
		try {
			char[] data = new char[1024];

			int e;
			while ((e = bufferedReader.read(data, 0, data.length)) != -1) {
				StringBuilder builder = new StringBuilder(e);
				builder.append(data, 0, e);
				this.print(builder.toString());
			}
		} catch (Exception arg4) {
			arg4.printStackTrace();
		}

	}

	public void destroy() {
		ThreadHelper.start(() -> {
			while (Objects.isNull(this.process)) {
				ThreadHelper.sleep(250);
			}

			this.process.destroy();
			IOHelper.close(new Closeable[] { this.inputReader, this.errorReader, this.outputWriter });
		});
	}

	@WebkitCall(from = "hterm")
	public void copy(String text) {
		Clipboard clipboard = Clipboard.getSystemClipboard();
		ClipboardContent clipboardContent = new ClipboardContent();
		clipboardContent.putString(text);
		clipboard.setContent(clipboardContent);
	}
	
	public Optional<String> unixTerminalCharset() {
		String[] charset = new String[] { null };

		try {
			Process e = Runtime.getRuntime().exec(new String[] { this.termCommand[0], "-c", "locale charmap" });
			String result = ((String) (new BufferedReader(new InputStreamReader(e.getInputStream()))).lines()
					.collect(Collectors.joining("\n"))).trim();
			if (!result.isEmpty()) {
				charset[0] = result;
			}
		} catch (Exception arg3) {
			return Optional.empty();
		}

		return Optional.ofNullable(charset[0]);
	}

	public Optional<String> windowsCmdCharset() {
		String[] charset = new String[] { null };

		try {
			Process e = Runtime.getRuntime().exec(new String[] { this.termCommand[0], "/C", "chcp" });
			String result = ((String) (new BufferedReader(new InputStreamReader(e.getInputStream()))).lines()
					.collect(Collectors.joining("\n"))).split(":")[1].trim();
			if (!result.isEmpty()) {
				Integer chcp = Integer.valueOf(result);
				charset[0] = "CP" + chcp;
			}
		} catch (Exception arg4) {
			return Optional.empty();
		}

		return Optional.ofNullable(charset[0]);
	}

	public void setTerminalPath(Path terminalPath) {
		this.terminalPath = terminalPath;
	}

	public Path getTerminalPath() {
		return this.terminalPath;
	}

	public boolean isReady() {
		return this.isReady;
	}

	public TerminalConfig getTerminalConfig() {
		if (Objects.isNull(this.terminalConfig)) {
			this.terminalConfig = new TerminalConfig();
		}

		return this.terminalConfig;
	}

	public void setTerminalConfig(TerminalConfig terminalConfig) {
		this.terminalConfig = terminalConfig;
	}
}
